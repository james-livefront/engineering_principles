# Each principle includes why it matters, how it happens, and enforcement mechanisms

principles:
  accessibility:
    category: "User-First"
    why: "Equal access to the digital products we build—regardless of ability or disability—is essential"
    how:
      - "We aim to support the widest possible audience"
      - "Every feature and function must be accessible"
      - "Accessibility is verified during code review for every feature"
    requirements:
      all_platforms:
        - contrast_ratios
        - dynamic_font_sizes
        - touch_target_sizes
        - screen_reader_support
      web_specific:
        - semantic_html
        - wcag_2_1_compliance
    enforcement:
      automated_checks: "Verify accessibility attributes are present: aria-labels, role attributes, semantic HTML elements"
      manual_review: "Check contrast ratios meet WCAG 2.1 AA standards, verify keyboard navigation works, test with screen readers"
      severity_escalation: "Flag missing accessibility as CRITICAL for user-facing features, REQUIRED for internal tools"

  code_consistency:
    category: "Craft Excellence"
    why: "Consistent code style makes developers lives easier and clients happier"
    benefits:
      - "Code is more readable and maintainable"
      - "Onboarding new developers is fast and fun"
      - "Our high bar for quality is easier to hold"
      - "Our code reflects the skill and mastery expected of us by clients"
    how:
      - "We use linters on every platform"
      - "We have a style guide for every platform"
      - "Style is checked manually during code review"
    enforcement:
      automated_checks: "Verify consistent naming conventions, indentation, and formatting match platform standards"
      manual_review: "Check for consistent patterns across similar code, ensure readability and maintainability"
      severity_escalation: "Flag inconsistencies as RECOMMENDED improvements, escalate to REQUIRED if impacting team productivity"

  zero_todos:
    category: "Technical Debt Prevention"
    why: "When you add a TODO to source code, you're defining future scope or technical debt. The work becomes lost over time and introduces confusion."
    how:
      - "We avoid adding TODOs to the source code"
      - "Any work defined by a TODO must be tracked separately, outside the source code"
      - "Every TODO must be accompanied by a link to a ticket"
    decision_tree:
      - question: "Can this be done now?"
        yes: "Do it now"
        no: "Create ticket and link in comment"
    enforcement:
      automated_checks: "Search for patterns: TODO, FIXME, HACK, XXX in source files, verify each has linked ticket"
      manual_review: "Check that any remaining work items have corresponding tickets, ensure TODO removal process is followed"
      severity_escalation: "Flag TODOs without tickets as BLOCKING, flag excessive TODOs as technical debt requiring immediate attention"

  security:
    category: "User Protection"
    why: "Our clients trust us to help them protect private customer and company information"
    how:
      - "We use HTTPS everywhere"
      - "We never store secrets or keys in source control"
      - "We never use personal repos"
      - "We always assume confidentiality"
      - "We encrypt private information on-device"
    platform_specific:
      ios: "Keychain for private data"
      android: "Encrypted SharedPreferences"
      web: "No local storage of sensitive data"
    enforcement:
      automated_checks: "Scan for hardcoded secrets, API keys, passwords using regex patterns; verify HTTPS usage; check for encrypted storage"
      manual_review: "Validate authentication flows, verify sensitive data handling, check certificate pinning implementation"
      severity_escalation: "Flag security violations as CRITICAL (hardcoded secrets, HTTP usage), BLOCKING (weak crypto), REQUIRED (missing encryption)"

  unidirectional_data_flow:
    category: "Architecture"
    why: "Unidirectional data flow makes the outcome of state changes more predictable. Code is easier to understand, and apps are more reliable."
    how:
      - "We limit where state changes happen"
      - "Views display state, never change it"
      - "Isolation improves modularity"
      - "Modularity allows testing"
    patterns:
      android: "MVP/MVVM with RxJava"
      ios: "Coordinator pattern with state containers"
      web: "React + Redux"
    enforcement:
      automated_checks: "Verify state mutations happen only in designated classes (stores, view models, reducers)"
      manual_review: "Check that views only read state and emit events, validate data flow follows unidirectional patterns"
      severity_escalation: "Flag bidirectional data flow as BLOCKING, direct state mutations in views as REQUIRED fix"

  testing:
    category: "Reliability"
    why: "Writing testable code has a strong, positive influence on architecture"
    benefits:
      - "Tested code is more modular and more reliable"
      - "Tested code is easier to understand and change"
      - "Testing forces us to check our assumptions"
      - "Testing encourages writing smaller pieces of code"
    how:
      - "We require 80% minimum coverage on business logic"
      - "Test coverage is checked and confirmed by CI"
      - "Code can't be merged until it's tested"
    scope:
      required: ["business_logic", "data_transformations", "state_management"]
      optional: ["ui_code", "animations", "styling"]
    enforcement:
      automated_checks: "Calculate test coverage for business logic modules, verify CI fails on coverage below 80%"
      manual_review: "Validate test quality and meaningfulness, check that tests cover edge cases and error conditions"
      severity_escalation: "Flag coverage below 80% as BLOCKING for business logic, missing tests as REQUIRED for critical paths"

  flexible_layout:
    category: "User Experience"
    why: "People expect software to be beautiful regardless of the type and size of hardware being used"
    how:
      - "We build to accommodate a wide range of devices, screen sizes, and pixel densities"
      - "We build flexible UIs"
      - "We ensure image assets consistently scale"
      - "We support large font sizes for accessibility"
      - "We support portrait and landscape orientations as required"
    platform_specific:
      android: "Responsive, scalable layouts"
      ios: "Layout in code—no nibs"
      web: "Responsive layouts with CSS Grid/Flexbox"
    enforcement:
      automated_checks: "Verify responsive design patterns, check for hardcoded dimensions, validate support for different screen densities"
      manual_review: "Test layouts on different screen sizes and orientations, verify accessibility with large fonts"
      severity_escalation: "Flag layout breaks as BLOCKING for supported devices, hardcoded dimensions as REQUIRED fix"

  continuous_integration:
    category: "Process"
    why: "CI confirms the build is green, validates test coverage, automates repetitive tasks, and speeds up the feedback loop"
    how:
      - "We use GitHub Actions to build, test, and deploy"
      - "CI blocks merges on failures"
      - "Automated deployment of QA and release builds"
      - "Jira integration for ticket management"
    requirements:
      - build_automation
      - test_automation
      - lint_checks
      - coverage_reports
      - automated_deployment
    enforcement:
      automated_checks: "Verify CI pipeline runs all required checks (build, test, lint), ensure merge protection rules are active"
      manual_review: "Validate CI configuration covers all quality gates, check deployment automation is working correctly"
      severity_escalation: "Flag CI failures as BLOCKING for merges, missing CI steps as REQUIRED infrastructure fixes"

  code_reviews:
    category: "Knowledge Sharing"
    why: "Peer-review helps us stay consistent, be correct more often, and share implementation and design knowledge across the team"
    how:
      - "Every line of code we write is peer-reviewed"
      - "Projects are hosted on GitHub"
      - "Automation provides a code review checklist"
      - "Code cannot be merged until checklist complete and approved"
    requirements:
      - checklist_completion
      - peer_approval
      - ci_passing
    enforcement:
      automated_checks: "Verify PR has required approvals, ensure all CI checks pass before merge, validate checklist completion"
      manual_review: "Conduct thorough code review focusing on logic, security, and maintainability, provide constructive feedback"
      severity_escalation: "Flag unreviewed code as BLOCKING for merge, insufficient review feedback as REQUIRED process violation"

  zero_build_warnings:
    category: "Code Quality"
    why: "Warnings are real indicators of potential problems, and they mask other problems if not addressed"
    how:
      - "We report build warnings automatically during CI"
      - "We suppress irrelevant warnings with explanation"
      - "Keep codebase warning-free to spot new issues"
    enforcement:
      automated_checks: "Monitor build output for warnings, track warning trends over time, fail builds on new warnings"
      manual_review: "Review and justify any warning suppressions, ensure warnings are addressed or properly documented"
      severity_escalation: "Flag new build warnings as BLOCKING for merge, excessive warnings as REQUIRED cleanup task"

  design_integrity:
    category: "Craft Excellence"
    why: "We set ourselves apart by delivering working software that fulfills the vision laid out in the designs"
    how:
      - "We pay close attention to small details"
      - "We consult directly with design team for questions"
      - "We verify implementation matches designs"
      - "We incorporate regular design audits"
    tools:
      - "Zeplin for design specs"
      - "Design review process"
      - "Pixel-perfect validation"
    enforcement:
      automated_checks: "Compare implementation screenshots against design specs, validate pixel-perfect accuracy where specified"
      manual_review: "Review implementation against designs with design team, ensure visual consistency across platform"
      severity_escalation: "Flag design deviations as REQUIRED fixes, missing designer approval as BLOCKING for UI changes"

  localization:
    category: "Global Reach"
    why: "Not everyone lives in your timezone, speaks your language, uses your currency, and formats dates like you do"
    how:
      - "We build apps with localization support from the beginning"
      - "Strings, dates, currencies are never hard-coded"
      - "Support being localized without architectural changes"
    requirements:
      - externalized_strings
      - locale_aware_formatting
      - rtl_support_ready
      - dynamic_layouts
    enforcement:
      automated_checks: "Scan for hardcoded strings, dates, currencies in UI code; verify externalized string usage"
      manual_review: "Check that all user-facing text is localization-ready, validate RTL layout support where needed"
      severity_escalation: "Flag hardcoded user-facing strings as REQUIRED fixes, missing localization prep as RECOMMENDED improvements"

  minimal_dependencies:
    category: "Risk Management"
    why: "We're responsible for maintaining every single line of code we ship"
    risks:
      - "More libraries are abandoned than maintained"
      - "Dependencies have dependencies (fragile networks)"
      - "When critical dependencies break, we can't wait"
      - "Our code is easier to understand than others'"
    how:
      - "All libraries must be approved by VP Technology and client"
      - "All libraries documented in README with purpose and license"
      - "Build vs buy analysis for each dependency"
    enforcement:
      automated_checks: "Monitor dependency additions, validate against approved library lists, check license compatibility"
      manual_review: "Review new dependencies against build vs buy analysis, ensure VP Technology and client approval obtained"
      severity_escalation: "Flag unapproved dependencies as BLOCKING for merge, missing documentation as REQUIRED fixes"

  compatibility:
    category: "Platform Support"
    why: "Required support for operating systems, device hardware, and APIs varies by project"
    how:
      - "Supported versions determined by client and product team"
      - "Documented in README for each repository"
      - "Tested across all supported configurations"
    documentation:
      - minimum_os_versions
      - supported_devices
      - browser_matrix
      - api_levels
    enforcement:
      automated_checks: "Run compatibility tests across supported OS versions and device types, validate API usage"
      manual_review: "Test on physical devices representing supported configurations, verify graceful degradation"
      severity_escalation: "Flag compatibility breaks as BLOCKING for supported platforms, deprecation warnings as REQUIRED updates"

  documentation:
    category: "Knowledge Transfer"
    why: "Documentation helps all stakeholders understand what we did, how we did it, and why we did it"
    how:
      - "We document our source code (public and internal interfaces)"
      - "We document our repositories (README essentials)"
    readme_requirements:
      - dev_setup
      - build_and_test_process
      - release_process
      - compatibility_matrix
      - dependencies_list
      - architecture_overview
      - automation_details
      - ci_setup
    enforcement:
      automated_checks: "Verify README completeness, check for missing inline documentation on public APIs"
      manual_review: "Review documentation accuracy and clarity, ensure new features are documented"
      severity_escalation: "Flag missing README sections as REQUIRED for new projects, undocumented APIs as RECOMMENDED improvements"
